---
title: "Práctica 5. Datos Anómalos"
subtitle: "Análisis Exploratorio de Datos, Máster en Ciencia de Datos - UV"
output:
  html_document:
    echo: yes
    number_sections: no
    theme: lumen
    toc: yes
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: no
---

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}
# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)
# Opciones generales chunks
opts_chunk$set(echo = T, message = F, error = F, warning = F,
               comment = NA, fig.align = 'center', dpi = 100, tidy = F,
               cache.path = '.cache/', fig.path = './figure/')
# options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
# knit_hooks$set(plot = knitr:::hook_plot_html)
knitr::opts_chunk$set(fig.width=8, fig.height=4)
```


```{r}
library(pacman)
packages = c("knitr", "ggplot2","tidyr","dplyr","readr")
pacman::p_load(char=packages)

```

```{r Solucion opciones visualizacion, eval=F, include=F}
# {r Solucion ejercicio xxx, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE} 
# para generar nuestra versión con todas las soluciones.
# {r Solucion ejercicio xxx, include=TRUE, echo=FALSE, eval=TRUE, results= FALSE}
# para generar su versión sin código ni resultados numéricos pero con las gráficas.
```


# Introducción y objetivos

El objetivo de esta práctica es comprobar si los conjuntos de datos con los que vamos a trabajar son consistentes y, por tanto, pueden ser empleados para realizar un análisis sin errores.
Las observaciones contenidas en los datos pueden presentar diferentes tipos de inconsistencias, como valores perdidos (missing values), valores especiales y valores anómalos (outliers).

Para evitar estas inconsistencias, estos datos deberán ser eliminados, corregidos o imputados. Siendo las etapas que pueden seguirse para obtener datos consistentes:

  1. Detección de las inconsistencias.
  2. Detectar el campo o campos que la generan y las dependencias entre ellos.
  3. Corrección de errores.

Vamos a trabajar con el conjunto de datos *dirty_iris*, que ya conocemos, que contiene datos perdidos, valores especiales y anomalías de carácter numérico respecto a la distribución de los datos (``dirty_iris.csv``).

```{r}
rm(list=ls())
dirty_iris <- read_csv("data/dirty_iris.csv")
```

# Detección de inconsistencias en los datos

Por lo general, no hay un convenio o una representación común para indicar un dato perdido o incluso determinados valores especiales. En los siguientes ejercicios vamos a analizar cómo detectar inconsistencias presentes en los datos.

## Ejercicio 1: Inspección Visual

Inspecciona visualmente los valores del conjunto de datos (`View`) y ordena de mayor a menor y de menor a mayor cada variable para descubrir las diferentes inconsistencias que presenta el conjunto `dirty_iris`. Comenta los valores que te llamen la atención.
```{r Solucion ejercicio 1, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
# Medidas con valores faltantes, longitudes negativas y cero

# ARRANGE ordenar descendentemente
View(dirty_iris)
dirty_iris %>% arrange(desc(dirty_iris$Sepal.Length))
dirty_iris %>% arrange(desc(dirty_iris$Petal.Length))
dirty_iris %>% arrange(desc(dirty_iris$Sepal.Width))
dirty_iris %>% arrange(desc(dirty_iris$Petal.Width))

# ascendentemente
dirty_iris %>% arrange(dirty_iris$Sepal.Length)
dirty_iris %>% arrange(dirty_iris$Petal.Length)
dirty_iris %>% arrange(dirty_iris$Sepal.Width)
dirty_iris %>% arrange(dirty_iris$Petal.Width)
```

## Ejercicio 2: Valores especiales

Visualizar los datos puede ser muy revelador, pero en general, especialmente para conjuntos de datos grandes, realizaremos este análisis de forma automática.

Los valores especiales más comunes en R son:

  * NA (_not available_): missing value o dato perdido (`is.na`)
  * NULL (_empty set_): elemento nulo de longitud 0 (`is.null`)
  * NaN (_not a number_): indeterminación con resultado desconocido (`is.nan`)
  * Inf (_infinite_): valor numérico de valor infinito (`is.infinite`)

Nota: A parte de estas funciones, `is.numeric` comprueba si la variable es numérica;  `is.finite` comprueba la existencia de cualquier valor especial en un vector numérico pero devuelve `FALSE` para variables de texto.

Reemplaza, en todas las columnas numéricas del data frame `dirty_iris`, los valores que sean especiales (usando `is.finite`), negativos, o iguales a cero, por `NA`. 
Nota: Puedes reemplazar los valores para cada variable del dataframe usando `mutate` con la función `ifelse`.
```{r}
# Comprobamos na, null...
dirty_iris %>% is.na()
dirty_iris %>% is.null()
# no funcionan sobre dataframes is.nan, is.infinite..., utilizamos SAPPLY
dirty_iris %>% sapply(is.nan)
dirty_iris %>% sapply(is.infinite)
dirty_iris %>% sapply(is.numeric) # para comprobar que variables son numéricas
dirty_iris %>% sapply(is.finite) # para variables de texto devuelve FALSE

# Reemplzar valores especiales, negativos, =0 por NA sobre las columnas numéticas
# en vez de usar across(where()) también puedo usar primero select(-Species) y luego across(everything)
# hay que poner ~ porque vamos a usar una función
# hay que indicar .x para que vaya cogiendo cada columna del across
dirty_iris <- dirty_iris %>% 
  mutate(across(where(is.numeric), ~ifelse(.x<=0 | is.infinite(.x), NA, .x)))
```

## Ejercicio 3: Valores perdidos y observaciones completas

  * Calcula el número y porcentaje de observaciones completas (muestras sin ningún dato perdido) empleando `complete.cases` (detecta todos los registros sin datos faltantes).
  * Emplea después la función `na.omit` para quedarnos solo con las filas con datos completos en un nuevo data frame `clean_iris`.
```{r Solucion ejercicio 3, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
# `complete.cases` (detecta todos los registros sin datos faltantes)
# sumo todos los registros completos
sum(complete.cases(dirty_iris))

# porcentaje (entre el número total de registros)
sum(complete.cases(dirty_iris))/nrow(dirty_iris)

# `na.omit` para quedarnos solo con las filas con datos completos en un nuevo data frame `clean_iris`
clean_iris <- na.omit(dirty_iris)
head(clean_iris)
```

# Detección de outliers univariante

Un outlier es una observación (o conjunto de observaciones) que no parecen consistentes con el resto de valores de esa variable. Por lo general, esas observaciones divergirán del patrón de comportamiento del resto de datos, es decir, presentarán una desviación respecto de la distribución de los datos.

En esta sección, vamos a centrarnos en métodos de detección univariantes, así que, en los ejercicios, a modo de ejemplo, analizaremos solo la variable `Petal.Length`.

## Ejercicio 4: Estadísticos básicos

La presencia de outliers puede producir una gran influencia en caracterizaciones sencillas de los datos, como la media y la desviación típica.

Empleado la función `summarise y across`, calcula la media, la desviación típica, mediana, la  _median absolute deviation from the median_ (MADM) y el _interquartile range_ (IQR) de las variables numéricas. 
Hazlo para el data frame con observaciones completas `clean_iris` (que no tiene NA pero tiene menos observaciones) y para el data frame con datos faltantes `dirty_iris` (que presenta muchos NA pero tiene todas las observaciones).

  * Ten en cuenta que no se puede realizar un análisis estadístico con datos faltantes, pero en la mayoría de los casos se puede optar por no considerar dichos valores al realizar los cálculos (parámetro `na.rm=TRUE`).
  * Para obtener el valor MADM, escribe una función `madm(x)` que sea robusta a la presencia de valores NA. Recuerda que el MADM se calcula como $1.4826\cdot\textrm{median}(|x - \textrm{median(x)}|)$.
  * Compara los resultados para los dos conjuntos en la variable `Petal.Length`.
```{r}
# para el df limpio
clean_iris %>% summarise(across(where(is.numeric),list(media=mean, mediana=median, desviacion=sd, madm=mad, IQR=IQR)))

# para el df no limpio
dirty_iris %>% summarise(across(where(is.numeric), list(media=~mean(.x, na.rm = TRUE), mediana=~median(.x, na.rm = TRUE), desviacion=~sd(.x, na.rm = TRUE), madm=~mad(.x, na.rm = TRUE), IQR=~IQR(.x, na.rm = TRUE)))) # para que no incluya los NA (ni los sume ni los cuente)
```

## Ejercicio 5: Métodos de detección de outliers

Escribe una función que detecte los outliers de un vector $x$ para cada uno de los siguientes métodos de detección de outliers univariantes (todas las funciones tienen que ser robustas a la presencia de valores NA).

  * **Regla 3 sigma** `reglasigma(x)`: Considera que los datos siguen una distribución gaussiana. Datos típicos caracterizados por la media y la dispersión por la varianza. Valores por encima de 3 desviaciones típicas se consideran outliers.

  * **Identificador Hampel** `reglahampel(x)`: Utiliza estimadores robustos y no presupone que los datos siguen una distribución gaussiana. Datos típicos caracterizados por la mediana y la dispersión por la _median absolute deviation from the median_ (MADM). Valores por encima de 3 MADM se consideran outliers.

  * **Regla boxplot** `reglaboxplot(x)`: A partir de los datos se calcula su diagrama de caja (boxplot) y se definen como datos típicos superiores hasta el cuartil 75%, $x_s$; datos típicos inferiores hasta el cuartil 25%, $x_i$; y la dispersión se define como el rango intercuartílico ($IQR= x_s-x_i$). Valores por encima de $x_s+1.5\cdot IQR$ o por debajo de $x_i-1.5\cdot IQR$ se consideran outliers. Usa la función `quantile` para calcular los cuartiles.

  * **Percentiles** `reglapercentil(x)`: Cualquier valor que esté fuera del rango del percentil 5% y 95% se puede considerar como atípico. Usa la función `quantile` para calcular los percentiles.

```{r , include = FALSE}
# Regla 3 sigma
# x sería una columna del dataframe
# queremos que retorne un vector lógico con todos los valores para después en los siguientes ejercicios
regla3sigma <- function(x){
  res <- abs(x-mean(x, na.rm=T))>3*sd(x, na.rm=T)
  return(res)
}

# Identificador Hampel
reglahampel <- function(x){
  mediana <- median(x, na.rm=T)
  madm <- mad(x, na.rm=T)
  res <- abs(x-mediana)>3*madm
  return(res)
}

# Regla boxplot
reglaboxplot <- function(x){
  x_iqr <- IQR(x)
  x_Q <- quantile(x, probs=c(0.25,0.5,0.75))
  res <- x>x_Q[[3]]+1.5*x_iqr|x<x_Q[[1]]-1.5*x_iqr
  return(res)
}

# Percentiles
reglapercentil <- function(x){
  x_Q <- quantile(x, probs=c(0.25,0.5,0.75))
  res<- x>x_Q[[3]]|x<x_Q[[1]]
  return(res)
}
```


## Ejercicio 6: Detección de outliers

Utiliza la función `mutate` y `across` para identificar los outliers en la variable `Petal.Length` con todos los métodos de detección de outliers implementados. Genera una columna nueva para cada método. 
Nota: podría extenderse la aplicación a todas las variables numéricas usando también `mutate`, `across` y `where`. 

```{r}
iris_out <- clean_iris %>% 
  mutate(across(where(is.numeric), list('Outliers 3sigma'=~regla3sigma(.x), 'Outliers Hampel'=~reglahampel(.x),'Outliers boxplot'=~reglaboxplot(.x), 'Outliers percentil'=~reglapercentil(.x))))
head(iris_out)
```

## Ejercicio 7: Comparativa de los métodos de detección de outliers

En los métodos de detección de outliers analizados, examina los resultados comparando:

  * Número de outliers detectados por método.
  * Los valores etiquetados como outliers (ordenados de menor a mayor).

```{r Solucion ejercicio 7, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
clean_iris %>% 
  summarise(across(where(is.numeric), list('Num outliers 3sigma'=~sum(regla3sigma(.x)), 'Num outliers Hampel'=~sum(reglahampel(.x)), 'Num outliers boxplot'=~sum(reglaboxplot(.x)),'Num outliers percentil'=~sum(reglapercentil(.x)))))
```

## Ejercicio 8: Representación gráfica

Representa gráficamente los datos de `Petal.Length` (distribución de puntos en el eje $y$) para todas las reglas de detección implementadas (repartidas en el eje $x$) mostrando los valores identificados como típicos y los identificados como outliers en diferente color. Usa la función `pivot_longer` para poder agrupar por reglas y colorear los outliers fácilmente.

Nota: usa en `geom_point` con la opción `position='jitter'` para mejorar la legibilidad del gráfico.

```{r Solucion ejercicio 8, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
library(ggplot2)

# Usa la función `pivot_longer` para poder agrupar por reglas y colorear los outliers fácilmente

iris_out1 <- iris_out %>% pivot_longer(col=6:21, names_to='clasificacion', values_to='logical') %>% separate(col=clasificacion, into=c('tipo', 'regla'), sep=' ')
head(iris_out1)

iris_out1 %>% ggplot() + geom_point(aes(x=regla, y=Petal.Length, color=logical), position='jitter')
  
```

# Imputación de datos

Como se ha visto, con _missing data_ nos referimos a una observación (o conjunto de observaciones) cuyo valor no es conocido. 

Vamos a ver a continuación ejemplos de cómo imputar valores realistas a esas observaciones perdidas.

## Ejercicio 9: Imputación de datos perdidos con estadísticos básicos

La opción más sencilla es imputar con un valor estimado de los valores conocidos (por ejemplo, con la media, la mediana, o la moda).

Se puede realizar una imputación generalizada (usando todos los valores de la variable) o una imputación a partir de casos similares (la estimación se realiza teniendo en cuenta otra variable):

  * Imputa los missing data en `Petal.Length` empleando la media. Nota: Puedes reemplazar los valores vacios usando `mutate` con `ifelse` creando una nueva variable `Petal.Length1`.

```{r Solucion ejercicio 9a, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
dirty_iris1 <- dirty_iris %>% mutate(petal.length1=  ifelse(is.na(Petal.Length), mean(Petal.Length, na.rm=T), Petal.Length))
View(dirty_iris1)
```

  * Imputa los missing data en `Petal.Length` empleando en esta ocasión la media para cada tipo de `Species` (usar`group_by` y `mutate`) creando una nueva variable `Petal.Length2`.

```{r Solucion ejercicio 9b, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
dirty_iris_group <- dirty_iris %>% group_by(Species)  %>% mutate(petal.length2=ifelse(is.na(Petal.Length), mean(Petal.Length, na.rm=T), Petal.Length)) %>% ungroup()
head(dirty_iris_group)
```

## Ejercicio 10: Representación gráfica

Vamos a comparar ahora los dos métodos de imputación gráficamente eliminando los outliers para una mejor visualización.

  * Recalcula las reglas de identificación de outliers (Ejercicio 6) para la nueva variable `Petal.Length2`.
  
```{r Solucion ejercicio 10a, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}
# con across se usa list y virgulilla
iris_out2 <- dirty_iris_group %>% 
  mutate('Outliers 3sigma'=regla3sigma(petal.length2), 'Outliers Hampel'=reglahampel(petal.length2),'Outliers boxplot'=reglaboxplot(petal.length2), 'Outliers percentil'=reglapercentil(petal.length2))
head(iris_out2)

iris_out3 <- dirty_iris1%>% 
  mutate('Outliers 3sigma'=regla3sigma(petal.length1), 'Outliers Hampel'=reglahampel(petal.length1),'Outliers boxplot'=reglaboxplot(petal.length1), 'Outliers percentil'=reglapercentil(petal.length1))
 head(iris_out3)
```

  * Representa los dos tipos de imputación empleados en un gráfico de dispersión (`Petal.Length1` vs. `Petal.Length2`) eliminando los outliers identificados con la regla `reglapercentil` y poniendo en diferente color los datos originales y los imputados.

```{r Solucion ejercicio 10b, include=TRUE, echo=TRUE, eval=TRUE, results=TRUE}

```



